//LinkedList.h

#pragma once
#include <iostream>
using namespace std;


// declaring node class
template<class T>
class LinkedList {

private:

	struct Node {
		T value;
		Node* next;
	};

	Node* head;

public:

	// default constructor
	LinkedList() : head(nullptr) { }

	// copy constructor
	LinkedList(const LinkedList<T>& rhs);

	// Destroys all the dynamically allocated memory
	// in the list.
	~LinkedList();

	// assignment operator
	const LinkedList<T>& operator=(const LinkedList<T>& rhs);

	// Inserts val at the front of the list
	void insertToFront(const T& val);

	// Prints the LinkedList
	void printList() const;

	// Sets item to the value at position i in this
	// LinkedList and return true, returns false if
	// there is no element i
	bool get(int i, T& item) const;

	// Reverses the LinkedList
	void reverseList();

	// Prints the LinkedList in reverse order
	void printReverse() const;

	// Appends the values of other onto the end of this
	// LinkedList.
	void append(const LinkedList<T>& other);

	// Exchange the contents of this LinkedList with the other one.
	void swap(LinkedList<T>& other);

	// Returns the number of items in the Linked List.
	int size() const;
};

// copy constructor to copy the contents of rhs into this
template<class T>
LinkedList<T>::LinkedList(const LinkedList<T>& rhs)
{
	// this makes the head null
	head = nullptr;
	// let node point to head of rhs
	Node* node = rhs.head;

	// loop that continues till the end of rhs, inserting the elements into the end of this list
	while (node != nullptr)
	{
		insertToFront(node->value);
		node = node->next;
	}
}

// destructor function to delete list compnents
template<class T>
LinkedList<T>::~LinkedList()
{
	while (head != nullptr)
	{
		Node* temp = head;
		head = head->next;
		delete(temp);
	}
}

// assignment operator that copies the contents of rhs into this
template<class T>
const LinkedList<T>& LinkedList<T>::operator=(const LinkedList<T>& rhs)
{

	if (this != &rhs)
	{
		// removes the contents of current list
		while (head != nullptr)
		{
			Node* temp = head;
			head = head->next;
			delete(temp);
		}
		// make curr point to head of rhs
		Node* curr = rhs.head;

		// loop till the end of rhs copying the elements at the end of this list
		while (curr != nullptr)
		{
			insertToFront(curr->value);
			curr = curr->next;
		}
	}

	return *this;
}

// this function inserts the elements at the end of the list
template<class T>
void LinkedList<T>::insertToFront(const T& val)
{
	Node* node = new Node;
	node->value = val;
	node->next = nullptr;
	// empty list
	if (head == nullptr)
		head = node;
	else
	{
		Node* curr = head;
		// loop till the last node of the list
		while (curr->next != nullptr)
			curr = curr->next;
		curr->next = node;
	}
}

// this function prints the list
template<class T>
void LinkedList<T>::printList() const
{
	if (head == nullptr) // empty list
		std::cout << "The list is empty" << std::endl;
	else
	{
		Node* curr = head;
		// loop over the end of the list, print the elements of the list
		while (curr != nullptr)
		{
			std::cout << curr->value << " ";
			curr = curr->next;
		}

		std::cout << std::endl;
	}
}

// function to return the ith position element in item
template<class T>
bool LinkedList<T>::get(int i, T& item) const
{
	// if valid position
	if (i >= 0 && i < size())
	{
		int idx = 0;
		Node* curr = head;
		// loop over the list to get the ith node
		while (idx < i)
		{
			curr = curr->next;
			idx++;
		}

		item = curr->value;
		return true;
	}
	return false; // invalid position
}

// function to reverse the list
template<class T>
void LinkedList<T>::reverseList()
{
	// empty or one element list, return
	if (head != nullptr && head->next != nullptr)
	{
		Node* prev = nullptr; // set prev node to null
		Node* curr = head; // set curr to head
		Node* next;

		// loop till the end of list
		while (curr != nullptr)
		{
			next = curr->next; // set next to node next to curr
			curr->next = prev;
			prev = curr; // make prev point to curr
			curr = next;
		}

		head = prev; // update the new head
	}
}
// function to print the list in reverse
template<class T>
void LinkedList<T>::printReverse() const
{
	LinkedList revList(*this); // make revList to contain same elements as this list
	revList.reverseList(); // reverse the revList
	revList.printList(); // print the revList
}

// function to append the elements of other at the end of this list
template<class T>
void LinkedList<T>::append(const LinkedList<T>& other)
{
	Node* curr = other.head;
	// loop till the end of other inserting the elements at the end of this list
	while (curr != nullptr)
	{
		insertToFront(curr->value);
		curr = curr->next;
	}
}

// function to swap this list and other list contents
template<class T>
void LinkedList<T>::swap(LinkedList<T>& other)
{
	LinkedList tempList(*this);
	*this = other;
	other = tempList;
}

// function to return the size of the list
template<class T>
int LinkedList<T>::size() const
{
	int count = 0;
	Node* curr = head;
	// loop till the end of list counting the elements of the list
	while (curr != nullptr)
	{
		count++;
		curr = curr->next;
	}

	return count;
}

--------------------------------------------------------------------------------------------------------------
